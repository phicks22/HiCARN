"""
Created on Nov 10, 2019
Reading Hi-C data
@author : omega
"""

import os, sys
import warnings
import argparse
import numpy as np
import pandas as pd
from scipy.sparse import coo_matrix, csr_matrix, triu, tril

def converting_parser():
    parser = argparse.ArgumentParser(description='Converting HiC-Pro output to DeepHiC inputs')

    parser.add_argument('--bed', dest='bed', help='.bed file generated by HiC-Pro')
    parser.add_argument('--mat', dest='mat', help='.matrix file generated by HiC-Pro')
    parser.add_argument('-r', dest='resolution', help='resolution of the input file', default='10kb')
    parser.add_argument('-o', dest='out', help='output directory for converted files')

    return parser

def read_HiCPro(bedfile, matfile):
    """
    Fast loading of the .matrix and .bed files derived from HiC-Pro
    
    Parameters
    ----------
    bedfile : str,
        path to the .bed file which contains fragments info
    
    matfile : str,
        path to the .matrix file which contains contact counts

    Returns
    -------
    counts  : the interaction contacts map
    lengths : the lengths of each chromosomes
    chrs    : the chromosome names
    """
    
    ### read and parse fragments file at first
    bed_df = pd.read_csv(bedfile, sep='\t', comment="#", header=None, names=['chrs', 'starts', 'ends', 'idxs'])
    # get lengths for each chromosome
    chrs, indices, lengths = np.unique(bed_df.chrs.values, return_index=True, return_counts=True)
    
    chrs = list(chrs[indices.argsort()])
    lengths = lengths[indices.argsort()]
    base = bed_df.idxs[0] # start index: 0 or 1
    
    ### read and parse counts file then
    n = lengths.sum()
    shape = (n, n)
    
    # This is the interaction count files
    mat_df = pd.read_csv(matfile, sep='\t', comment="#", header=None)
    row, col, data = mat_df.values.T
    row = row.astype(int)
    col = col.astype(int)
    
    # If there are NAs remove them
    mask = np.isnan(data)
    if np.any(mask):
        warnings.warn(f'NAs detected in {mat_file}. Removing NAs and replacing with 0.')
        row = row[np.invert(mask)] # invert True and False for mask
        col = col[np.invert(mask)]
        data = data[np.invert(mask)].astype(int)
        
    # if index start from 1
    if base not in [0, 1]:
        raise ValueError('indices should start either at 0 or 1')
    if base == 1:
        col -= 1
        row -= 1
    
    # convert to a coo_matrix (lower triangular)
    counts = coo_matrix((data, (row, col)), shape=shape)
    
    # whether the matrix is lower or upper triangular
    if np.all(row <= col):
        triangular_upper = True
    elif np.all(row >= col):
        triangular_upper = False
    else:
        raise ValueError('The HiC matrix is neither lower nor upper triangular!')
    
    # We need to deal with the fact that we should not duplicate entries for the diagonal
    counts = csr_matrix(counts)  # CSR format is better for arithmetic
    # use sparse matrix functions here to save memory
    if triangular_upper:
        counts = counts + triu(counts, 1).transpose()
    else:
        counts = counts + tril(counts, -1).transpose()
    return counts, lengths, chrs


if __name__ == '__main__':
    print(f'Warning: Current script demands large memory (~250GB), a C++ based script will coming soon')
    args = converting_parser().parse_args(sys.argv[1:])

    bed_file = args.bed
    mat_file = args.mat

    resolution = args.resolution
    assert resolution=='10kb', "Input data must be binned at 10-kb"

    out_dir = args.out
    os.makedirs(out_dir, exist_ok=True)

    counts, lengths, chrs = read_HiCPro(bed_file, mat_file)

    starts = np.cumsum(np.concatenate([np.array([0]), lengths]))

    assert starts[-1]==counts.shape[0], 'Last end of indices is not match the matrix size'

    for i, chrn in enumerate(chrs):
        # instead of converting whole count matrix to dense array
        intra_counts = counts[starts[i]:starts[i+1], starts[i]:starts[i+1]].A  # convert sliced sparse matrix to dense array here
        compact = np.where(np.sum(intra_counts, axis=0)>0)[0]
        out_file = os.path.join(out_dir, f'{chrn}_{resolution}.npz')
        np.savez_compressed(out_file, hic=intra_counts, compact=compact)
        print(f'Saving {resolution} files to {out_file}')
